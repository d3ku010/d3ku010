name: Weekly README + Visitor Update

on:
  schedule:
    - cron: "0 0 * * MON"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate dynamic README sections
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const workspace = process.env.GITHUB_WORKSPACE;
            const readmePath = path.join(workspace, 'README.md');
            const statusPath = path.join(workspace, 'status.json');

            const now = new Date();
            const toISO = now.toISOString();
            const from = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const fromISO = from.toISOString();

            const owner = context.repo.owner;

            const query = `
              query($login: String!, $from: DateTime!, $to: DateTime!) {
                user(login: $login) {
                  repositories(first: 50, privacy: PUBLIC, ownerAffiliations: OWNER, orderBy: {field: UPDATED_AT, direction: DESC}) {
                    nodes {
                      name
                      description
                      url
                      stargazerCount
                      updatedAt
                      isFork
                      repositoryTopics(first: 20) {
                        nodes {
                          topic {
                            name
                          }
                        }
                      }
                      languages(first: 10, orderBy: {field: SIZE, direction: DESC}) {
                        edges {
                          size
                          node {
                            name
                          }
                        }
                      }
                    }
                  }
                  pinnedItems(first: 6, types: REPOSITORY) {
                    nodes {
                      ... on Repository {
                        name
                        description
                        url
                        stargazerCount
                        primaryLanguage {
                          name
                        }
                      }
                    }
                  }
                  contributionsCollection(from: $from, to: $to) {
                    totalCommitContributions
                    totalPullRequestContributions
                    totalIssueContributions
                    totalPullRequestReviewContributions
                    commitContributionsByRepository(maxRepositories: 5) {
                      contributions {
                        totalCount
                      }
                      repository {
                        name
                        url
                      }
                    }
                  }
                }
              }
            `;

            const data = await github.graphql(query, {
              login: owner,
              from: fromISO,
              to: toISO
            });

            const user = data.user;
            const repos = user.repositories.nodes.filter(repo => repo && !repo.isFork);

            const aggregateLanguages = () => {
              const totals = {};
              for (const repo of repos) {
                const langEdges = (repo.languages && repo.languages.edges) ? repo.languages.edges : [];
                for (const edge of langEdges) {
                  totals[edge.node.name] = (totals[edge.node.name] || 0) + edge.size;
                }
              }
              return Object.entries(totals)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8)
                .map(([name]) => name);
            };

            const topicCounts = {};
            for (const repo of repos) {
              const topicNodes = (repo.repositoryTopics && repo.repositoryTopics.nodes) ? repo.repositoryTopics.nodes : [];
              for (const node of topicNodes) {
                if (!node || !node.topic || !node.topic.name) {
                  continue;
                }
                const key = node.topic.name.toLowerCase();
                topicCounts[key] = (topicCounts[key] || 0) + 1;
              }
            }

            const taxonomy = {
              frameworks: [
                { match: 'react-native', label: 'React Native' },
                { match: 'react', label: 'React' },
                { match: 'next', label: 'Next.js' },
                { match: 'dotnet', label: '.NET' },
                { match: 'aspnet', label: 'ASP.NET Core' },
                { match: 'node', label: 'Node.js' },
                { match: 'express', label: 'Express' },
                { match: 'bootstrap', label: 'Bootstrap' }
              ],
              tools: [
                { match: 'docker', label: 'Docker' },
                { match: 'github-actions', label: 'GitHub Actions' },
                { match: 'azure-devops', label: 'Azure DevOps' },
                { match: 'eslint', label: 'ESLint' },
                { match: 'prettier', label: 'Prettier' },
                { match: 'git', label: 'Git' }
              ],
              databases: [
                { match: 'sql-server', label: 'SQL Server' },
                { match: 'postgres', label: 'PostgreSQL' },
                { match: 'mysql', label: 'MySQL' },
                { match: 'mongo', label: 'MongoDB' },
                { match: 'redis', label: 'Redis' },
                { match: 'sqlite', label: 'SQLite' }
              ],
              cloud: [
                { match: 'azure', label: 'Azure' },
                { match: 'aws', label: 'AWS' },
                { match: 'gcp', label: 'GCP' },
                { match: 'vercel', label: 'Vercel' },
                { match: 'netlify', label: 'Netlify' }
              ]
            };
            const curatedDefaults = {
              languages: ['C#', 'JavaScript', 'TypeScript', 'Python', 'SQL'],
              frameworks: ['.NET', 'ASP.NET Core', 'Entity Framework', 'Dapper', 'React', 'React Native'],
              tools: ['GitHub Actions', 'Docker', 'Git', 'Azure DevOps', 'Visual Studio'],
              databases: ['SQL Server', 'PostgreSQL', 'SQLite'],
              cloud: ['Azure', 'AWS']
            };

            const priorityOrder = {
              languages: ['C#', 'JavaScript', 'TypeScript', 'Python', 'SQL', 'HTML', 'CSS'],
              frameworks: ['.NET', 'ASP.NET Core', 'Entity Framework', 'Dapper', 'React', 'React Native', 'Next.js', 'Node.js', 'Express'],
              tools: ['GitHub Actions', 'Docker', 'Git', 'Azure DevOps', 'Visual Studio', 'ESLint', 'Prettier'],
              databases: ['SQL Server', 'PostgreSQL', 'SQLite', 'MongoDB'],
              cloud: ['Azure', 'AWS', 'GCP', 'Vercel', 'Netlify']
            };

            const collectCategory = (key) => {
              const descriptors = taxonomy[key];
              const results = [];
              for (const [topic, count] of Object.entries(topicCounts)) {
                for (const descriptor of descriptors) {
                  if (topic.includes(descriptor.match)) {
                    results.push({ label: descriptor.label, count });
                    break;
                  }
                }
              }
              results.sort((a, b) => b.count - a.count);
              const seen = new Set();
              const unique = [];
              for (const item of results) {
                if (!seen.has(item.label)) {
                  seen.add(item.label);
                  unique.push(item);
                }
              }
              return unique.map(item => item.label);
            };

            const uniqueList = (items) => {
              const seen = new Set();
              const ordered = [];
              for (const item of items) {
                if (!item || seen.has(item)) {
                  continue;
                }
                seen.add(item);
                ordered.push(item);
              }
              return ordered;
            };

            const orderByPreference = (items, key) => {
              const preferred = priorityOrder[key] || [];
              const featured = preferred.filter(entry => items.includes(entry));
              const remainder = items.filter(entry => !preferred.includes(entry)).sort((a, b) => a.localeCompare(b));
              return [...featured, ...remainder];
            };

            const getDisplayItems = (items, key) => {
              const unique = uniqueList(items);
              if (!unique.length) {
                return curatedDefaults[key] ? [...curatedDefaults[key]] : [];
              }
              return orderByPreference(unique, key);
            };

            const badgePalette = {
              languages: { labelColor: '0d1117', color: '1f6feb' },
              frameworks: { labelColor: '0d1117', color: 'a855f7' },
              tools: { labelColor: '0d1117', color: 'facc15' },
              databases: { labelColor: '0d1117', color: 'f97316' },
              cloud: { labelColor: '0d1117', color: '22c55e' }
            };

            const encodeBadgeLabel = (value) => encodeURIComponent(
              value
                .replace(/-/g, '--')
                .replace(/_/g, '__')
            );

            const renderBadges = (values, key) => {
              const palette = badgePalette[key] || badgePalette.languages;
              const color = palette.color;
              const labelColor = palette.labelColor;
              return values
              .map(value => {
                const encoded = encodeBadgeLabel(value);
                  return `![${value}](https://img.shields.io/badge/${encoded}-${color}?style=for-the-badge&labelColor=${labelColor})`;
              })
                .join(' ');
            };

            const renderRow = (label, key, values, fallback) => {
              const displayItems = getDisplayItems(values, key);
              return displayItems.length
                ? `**${label}:**\n${renderBadges(displayItems, key)}\n`
                : `**${label}:** ${fallback}\n`;
            };

            const languages = aggregateLanguages();
            const frameworks = collectCategory('frameworks');
            const tools = collectCategory('tools');
            const databases = collectCategory('databases');
            const cloud = collectCategory('cloud');

            const stackSection = [
              renderRow('Languages', 'languages', languages, 'Add public repositories to showcase languages.'),
              renderRow('Frameworks', 'frameworks', frameworks, 'Share repository topics to surface frameworks.'),
              renderRow('Tools', 'tools', tools, 'Tools will appear once repository topics are added.'),
              renderRow('Databases', 'databases', databases, 'Database badges will populate after the next sync.'),
              renderRow('Cloud', 'cloud', cloud, 'Cloud providers will sync in after topics/tags are added.')
            ].join('\n');

            const pinnedRepos = user.pinnedItems.nodes
              .filter(node => node && node.url)
              .map(repo => ({
                name: repo.name,
                description: repo.description,
                url: repo.url,
                stargazerCount: repo.stargazerCount || 0,
                primaryLanguage: repo.primaryLanguage ? repo.primaryLanguage.name : null
              }));

            const fallbackRepos = repos
              .map(repo => ({
                name: repo.name,
                description: repo.description,
                url: repo.url,
                stargazerCount: repo.stargazerCount || 0,
                primaryLanguage: (repo.languages && repo.languages.edges && repo.languages.edges.length)
                  ? repo.languages.edges[0].node.name
                  : null
              }))
              .sort((a, b) => b.stargazerCount - a.stargazerCount);

            const highlightSource = pinnedRepos.length ? pinnedRepos : fallbackRepos;
            const highlightLines = highlightSource.slice(0, 3).map(repo => {
              const desc = repo.description ? repo.description.replace(/\r?\n/g, ' ').trim() : 'No description added yet.';
              const lang = repo.primaryLanguage ? ` ¬∑ ${repo.primaryLanguage}` : '';
              const stars = repo.stargazerCount ? ` (‚≠ê ${repo.stargazerCount})` : '';
              return `- [${repo.name}](${repo.url}) ‚Äî ${desc}${lang}${stars}`;
            });

            const repoSection = highlightLines.length
              ? highlightLines.join('\n')
              : 'Add or pin repositories to surface highlights here.';

            const contributions = user.contributionsCollection;
            const totalsLine = `- Past 7 days: ${contributions.totalCommitContributions} commits ¬∑ ${contributions.totalPullRequestContributions} PRs ¬∑ ${contributions.totalPullRequestReviewContributions} reviews ¬∑ ${contributions.totalIssueContributions} issues`;

            const repoTouchLines = (contributions.commitContributionsByRepository || [])
              .map(entry => {
                if (!entry.repository) {
                  return null;
                }
                return `- [${entry.repository.name}](${entry.repository.url}) ‚Äî ${entry.contributions.totalCount} commits`;
              })
              .filter(Boolean)
              .slice(0, 5);

            const activitySection = [
              totalsLine,
              repoTouchLines.length ? repoTouchLines.join('\n') : '- Repos touched: awaiting public commits this week.'
            ].join('\n');

            const defaultStatus = {
              currentFocus: 'Designing resilient backend services and UI workflows.',
              learning: 'Deep-diving into distributed tracing and Azure patterns.',
              availability: 'Heads-down on shipping features, open to async chats.',
              note: 'Update status.json to personalize this panel.'
            };

            let statusData = defaultStatus;
            if (fs.existsSync(statusPath)) {
              try {
                statusData = JSON.parse(fs.readFileSync(statusPath, 'utf8'));
              } catch (error) {
                core.warning(`Unable to parse status.json: ${error.message}`);
              }
            }

            const statusLines = [
              statusData.currentFocus ? `- **Current Focus:** ${statusData.currentFocus}` : null,
              statusData.learning ? `- **Learning:** ${statusData.learning}` : null,
              statusData.availability ? `- **Availability:** ${statusData.availability}` : null,
              statusData.note ? `- **Note:** ${statusData.note}` : null
            ].filter(Boolean);

            const statusSection = statusLines.length
              ? statusLines.join('\n')
              : '- Update status.json to broadcast your current focus.';

            const injectSection = (content, marker, replacement) => {
              const start = `<!--${marker}_START-->`;
              const end = `<!--${marker}_END-->`;
              if (!content.includes(start) || !content.includes(end)) {
                throw new Error(`Marker ${marker} not found in README.md`);
              }
              const pattern = new RegExp(`${start}[\\s\\S]*?${end}`);
              return content.replace(pattern, `${start}\n${replacement}\n${end}`);
            };

            const readme = fs.readFileSync(readmePath, 'utf8');
            const updatedReadme = [
              ['STATUS_SECTION', statusSection],
              ['STACK_PANEL', stackSection],
              ['REPO_HIGHLIGHTS', repoSection],
              ['ACTIVITY_METRICS', activitySection]
            ].reduce((acc, [marker, value]) => injectSection(acc, marker, value), readme);

            fs.writeFileSync(readmePath, updatedReadme);

            core.info('README dynamic sections updated.');

      - name: Track unique visitors
        run: |
          FILE=visits.json
          if [ ! -f "$FILE" ]; then
            echo '{"count": 1, "last_ips": []}' > $FILE
          fi

          # Generate a random unique hash to simulate unique GitHub users
          HASH=$(echo $RANDOM | md5sum | cut -d' ' -f1)

          COUNT=$(jq '.count' $FILE)
          LAST_IPS=$(jq '.last_ips' $FILE)

          if [[ $LAST_IPS != *"$HASH"* ]]; then
            COUNT=$((COUNT+1))
            echo "{\"count\": $COUNT, \"last_ips\": [\"$HASH\"]}" > $FILE
          fi

          echo "Unique visitor count updated: $COUNT"

          # Update SVG badge
          echo "<svg xmlns='http://www.w3.org/2000/svg' width='160' height='30'>
            <rect width='160' height='30' fill='#1a1b27'/>
            <text x='15' y='20' fill='#70a5fd' font-family='Poppins' font-size='14'>
              üëÅÔ∏è Unique Visitors: $COUNT
            </text>
          </svg>" > visits.svg

      - name: Update README date
        run: |
          DATE=$(date +'%B %d, %Y')
          sed -i "s/Last updated: .*/Last updated: ${DATE} (auto-updated weekly via GitHub Actions)*/" README.md

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: weekly auto-update README + visitor count"
          commit_user_name: "github-actions[bot]"
          commit_user_email: "github-actions[bot]@users.noreply.github.com"
